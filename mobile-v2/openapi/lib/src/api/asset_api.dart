//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//

import 'dart:async';

import 'package:built_value/serializer.dart';
import 'package:dio/dio.dart';

import 'dart:typed_data';
import 'package:built_collection/built_collection.dart';
import 'package:openapi/src/api_util.dart';
import 'package:openapi/src/model/asset_bulk_delete_dto.dart';
import 'package:openapi/src/model/asset_bulk_update_dto.dart';
import 'package:openapi/src/model/asset_bulk_upload_check_dto.dart';
import 'package:openapi/src/model/asset_bulk_upload_check_response_dto.dart';
import 'package:openapi/src/model/asset_file_upload_response_dto.dart';
import 'package:openapi/src/model/asset_jobs_dto.dart';
import 'package:openapi/src/model/asset_order.dart';
import 'package:openapi/src/model/asset_response_dto.dart';
import 'package:openapi/src/model/asset_stats_response_dto.dart';
import 'package:openapi/src/model/asset_type_enum.dart';
import 'package:openapi/src/model/check_existing_assets_dto.dart';
import 'package:openapi/src/model/check_existing_assets_response_dto.dart';
import 'package:openapi/src/model/curated_locations_response_dto.dart';
import 'package:openapi/src/model/curated_objects_response_dto.dart';
import 'package:openapi/src/model/map_marker_response_dto.dart';
import 'package:openapi/src/model/memory_lane_response_dto.dart';
import 'package:openapi/src/model/thumbnail_format.dart';
import 'package:openapi/src/model/update_asset_dto.dart';
import 'package:openapi/src/model/update_stack_parent_dto.dart';

class AssetApi {

  final Dio _dio;

  final Serializers _serializers;

  const AssetApi(this._dio, this._serializers);

  /// checkBulkUpload
  /// Checks if assets exist by checksums
  ///
  /// Parameters:
  /// * [assetBulkUploadCheckDto] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [AssetBulkUploadCheckResponseDto] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<AssetBulkUploadCheckResponseDto>> checkBulkUpload({ 
    required AssetBulkUploadCheckDto assetBulkUploadCheckDto,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/bulk-upload-check';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      contentType: 'application/json',
      validateStatus: validateStatus,
    );

    dynamic _bodyData;

    try {
      const _type = FullType(AssetBulkUploadCheckDto);
      _bodyData = _serializers.serialize(assetBulkUploadCheckDto, specifiedType: _type);

    } catch(error, stackTrace) {
      throw DioException(
         requestOptions: _options.compose(
          _dio.options,
          _path,
        ),
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    final _response = await _dio.request<Object>(
      _path,
      data: _bodyData,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    AssetBulkUploadCheckResponseDto? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(AssetBulkUploadCheckResponseDto),
      ) as AssetBulkUploadCheckResponseDto;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<AssetBulkUploadCheckResponseDto>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// checkExistingAssets
  /// Checks if multiple assets exist on the server and returns all existing - used by background backup
  ///
  /// Parameters:
  /// * [checkExistingAssetsDto] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [CheckExistingAssetsResponseDto] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<CheckExistingAssetsResponseDto>> checkExistingAssets({ 
    required CheckExistingAssetsDto checkExistingAssetsDto,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/exist';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      contentType: 'application/json',
      validateStatus: validateStatus,
    );

    dynamic _bodyData;

    try {
      const _type = FullType(CheckExistingAssetsDto);
      _bodyData = _serializers.serialize(checkExistingAssetsDto, specifiedType: _type);

    } catch(error, stackTrace) {
      throw DioException(
         requestOptions: _options.compose(
          _dio.options,
          _path,
        ),
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    final _response = await _dio.request<Object>(
      _path,
      data: _bodyData,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    CheckExistingAssetsResponseDto? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(CheckExistingAssetsResponseDto),
      ) as CheckExistingAssetsResponseDto;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<CheckExistingAssetsResponseDto>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// deleteAssets
  /// 
  ///
  /// Parameters:
  /// * [assetBulkDeleteDto] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> deleteAssets({ 
    required AssetBulkDeleteDto assetBulkDeleteDto,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset';
    final _options = Options(
      method: r'DELETE',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      contentType: 'application/json',
      validateStatus: validateStatus,
    );

    dynamic _bodyData;

    try {
      const _type = FullType(AssetBulkDeleteDto);
      _bodyData = _serializers.serialize(assetBulkDeleteDto, specifiedType: _type);

    } catch(error, stackTrace) {
      throw DioException(
         requestOptions: _options.compose(
          _dio.options,
          _path,
        ),
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    final _response = await _dio.request<Object>(
      _path,
      data: _bodyData,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    return _response;
  }

  /// getAllAssets
  /// Get all AssetEntity belong to the user
  ///
  /// Parameters:
  /// * [ifNoneMatch] - ETag of data already cached on the client
  /// * [isArchived] 
  /// * [isFavorite] 
  /// * [skip] 
  /// * [take] 
  /// * [updatedAfter] 
  /// * [updatedBefore] 
  /// * [userId] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [BuiltList<AssetResponseDto>] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<BuiltList<AssetResponseDto>>> getAllAssets({ 
    String? ifNoneMatch,
    bool? isArchived,
    bool? isFavorite,
    int? skip,
    int? take,
    DateTime? updatedAfter,
    DateTime? updatedBefore,
    String? userId,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        if (ifNoneMatch != null) r'if-none-match': ifNoneMatch,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (isArchived != null) r'isArchived': encodeQueryParameter(_serializers, isArchived, const FullType(bool)),
      if (isFavorite != null) r'isFavorite': encodeQueryParameter(_serializers, isFavorite, const FullType(bool)),
      if (skip != null) r'skip': encodeQueryParameter(_serializers, skip, const FullType(int)),
      if (take != null) r'take': encodeQueryParameter(_serializers, take, const FullType(int)),
      if (updatedAfter != null) r'updatedAfter': encodeQueryParameter(_serializers, updatedAfter, const FullType(DateTime)),
      if (updatedBefore != null) r'updatedBefore': encodeQueryParameter(_serializers, updatedBefore, const FullType(DateTime)),
      if (userId != null) r'userId': encodeQueryParameter(_serializers, userId, const FullType(String)),
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    BuiltList<AssetResponseDto>? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(BuiltList, [FullType(AssetResponseDto)]),
      ) as BuiltList<AssetResponseDto>;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<BuiltList<AssetResponseDto>>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// getAllUserAssetsByDeviceId
  /// Get all asset of a device that are in the database, ID only.
  ///
  /// Parameters:
  /// * [deviceId] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [BuiltList<String>] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<BuiltList<String>>> getAllUserAssetsByDeviceId({ 
    required String deviceId,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/device/{deviceId}'.replaceAll('{' r'deviceId' '}', encodeQueryParameter(_serializers, deviceId, const FullType(String)).toString());
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    BuiltList<String>? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(BuiltList, [FullType(String)]),
      ) as BuiltList<String>;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<BuiltList<String>>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// getAssetInfo
  /// 
  ///
  /// Parameters:
  /// * [id] 
  /// * [key] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [AssetResponseDto] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<AssetResponseDto>> getAssetInfo({ 
    required String id,
    String? key,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/{id}'.replaceAll('{' r'id' '}', encodeQueryParameter(_serializers, id, const FullType(String)).toString());
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (key != null) r'key': encodeQueryParameter(_serializers, key, const FullType(String)),
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    AssetResponseDto? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(AssetResponseDto),
      ) as AssetResponseDto;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<AssetResponseDto>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// getAssetSearchTerms
  /// 
  ///
  /// Parameters:
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [BuiltList<String>] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<BuiltList<String>>> getAssetSearchTerms({ 
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/search-terms';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    BuiltList<String>? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(BuiltList, [FullType(String)]),
      ) as BuiltList<String>;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<BuiltList<String>>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// getAssetStatistics
  /// 
  ///
  /// Parameters:
  /// * [isArchived] 
  /// * [isFavorite] 
  /// * [isTrashed] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [AssetStatsResponseDto] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<AssetStatsResponseDto>> getAssetStatistics({ 
    bool? isArchived,
    bool? isFavorite,
    bool? isTrashed,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/statistics';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (isArchived != null) r'isArchived': encodeQueryParameter(_serializers, isArchived, const FullType(bool)),
      if (isFavorite != null) r'isFavorite': encodeQueryParameter(_serializers, isFavorite, const FullType(bool)),
      if (isTrashed != null) r'isTrashed': encodeQueryParameter(_serializers, isTrashed, const FullType(bool)),
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    AssetStatsResponseDto? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(AssetStatsResponseDto),
      ) as AssetStatsResponseDto;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<AssetStatsResponseDto>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// getAssetThumbnail
  /// 
  ///
  /// Parameters:
  /// * [id] 
  /// * [format] 
  /// * [key] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [Uint8List] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<Uint8List>> getAssetThumbnail({ 
    required String id,
    ThumbnailFormat? format,
    String? key,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/thumbnail/{id}'.replaceAll('{' r'id' '}', encodeQueryParameter(_serializers, id, const FullType(String)).toString());
    final _options = Options(
      method: r'GET',
      responseType: ResponseType.bytes,
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (format != null) r'format': encodeQueryParameter(_serializers, format, const FullType(ThumbnailFormat)),
      if (key != null) r'key': encodeQueryParameter(_serializers, key, const FullType(String)),
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    Uint8List? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : rawResponse as Uint8List;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<Uint8List>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// getCuratedLocations
  /// 
  ///
  /// Parameters:
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [BuiltList<CuratedLocationsResponseDto>] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<BuiltList<CuratedLocationsResponseDto>>> getCuratedLocations({ 
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/curated-locations';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    BuiltList<CuratedLocationsResponseDto>? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(BuiltList, [FullType(CuratedLocationsResponseDto)]),
      ) as BuiltList<CuratedLocationsResponseDto>;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<BuiltList<CuratedLocationsResponseDto>>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// getCuratedObjects
  /// 
  ///
  /// Parameters:
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [BuiltList<CuratedObjectsResponseDto>] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<BuiltList<CuratedObjectsResponseDto>>> getCuratedObjects({ 
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/curated-objects';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    BuiltList<CuratedObjectsResponseDto>? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(BuiltList, [FullType(CuratedObjectsResponseDto)]),
      ) as BuiltList<CuratedObjectsResponseDto>;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<BuiltList<CuratedObjectsResponseDto>>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// getMapMarkers
  /// 
  ///
  /// Parameters:
  /// * [fileCreatedAfter] 
  /// * [fileCreatedBefore] 
  /// * [isArchived] 
  /// * [isFavorite] 
  /// * [withPartners] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [BuiltList<MapMarkerResponseDto>] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<BuiltList<MapMarkerResponseDto>>> getMapMarkers({ 
    DateTime? fileCreatedAfter,
    DateTime? fileCreatedBefore,
    bool? isArchived,
    bool? isFavorite,
    bool? withPartners,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/map-marker';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (fileCreatedAfter != null) r'fileCreatedAfter': encodeQueryParameter(_serializers, fileCreatedAfter, const FullType(DateTime)),
      if (fileCreatedBefore != null) r'fileCreatedBefore': encodeQueryParameter(_serializers, fileCreatedBefore, const FullType(DateTime)),
      if (isArchived != null) r'isArchived': encodeQueryParameter(_serializers, isArchived, const FullType(bool)),
      if (isFavorite != null) r'isFavorite': encodeQueryParameter(_serializers, isFavorite, const FullType(bool)),
      if (withPartners != null) r'withPartners': encodeQueryParameter(_serializers, withPartners, const FullType(bool)),
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    BuiltList<MapMarkerResponseDto>? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(BuiltList, [FullType(MapMarkerResponseDto)]),
      ) as BuiltList<MapMarkerResponseDto>;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<BuiltList<MapMarkerResponseDto>>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// getMemoryLane
  /// 
  ///
  /// Parameters:
  /// * [day] 
  /// * [month] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [BuiltList<MemoryLaneResponseDto>] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<BuiltList<MemoryLaneResponseDto>>> getMemoryLane({ 
    required int day,
    required int month,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/memory-lane';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      r'day': encodeQueryParameter(_serializers, day, const FullType(int)),
      r'month': encodeQueryParameter(_serializers, month, const FullType(int)),
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    BuiltList<MemoryLaneResponseDto>? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(BuiltList, [FullType(MemoryLaneResponseDto)]),
      ) as BuiltList<MemoryLaneResponseDto>;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<BuiltList<MemoryLaneResponseDto>>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// getRandom
  /// 
  ///
  /// Parameters:
  /// * [count] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [BuiltList<AssetResponseDto>] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<BuiltList<AssetResponseDto>>> getRandom({ 
    num? count,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/random';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (count != null) r'count': encodeQueryParameter(_serializers, count, const FullType(num)),
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    BuiltList<AssetResponseDto>? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(BuiltList, [FullType(AssetResponseDto)]),
      ) as BuiltList<AssetResponseDto>;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<BuiltList<AssetResponseDto>>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// runAssetJobs
  /// 
  ///
  /// Parameters:
  /// * [assetJobsDto] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> runAssetJobs({ 
    required AssetJobsDto assetJobsDto,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/jobs';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      contentType: 'application/json',
      validateStatus: validateStatus,
    );

    dynamic _bodyData;

    try {
      const _type = FullType(AssetJobsDto);
      _bodyData = _serializers.serialize(assetJobsDto, specifiedType: _type);

    } catch(error, stackTrace) {
      throw DioException(
         requestOptions: _options.compose(
          _dio.options,
          _path,
        ),
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    final _response = await _dio.request<Object>(
      _path,
      data: _bodyData,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    return _response;
  }

  /// searchAssets
  /// 
  ///
  /// Parameters:
  /// * [checksum] 
  /// * [city] 
  /// * [country] 
  /// * [createdAfter] 
  /// * [createdBefore] 
  /// * [deviceAssetId] 
  /// * [deviceId] 
  /// * [encodedVideoPath] 
  /// * [id] 
  /// * [isArchived] 
  /// * [isEncoded] 
  /// * [isExternal] 
  /// * [isFavorite] 
  /// * [isMotion] 
  /// * [isNotInAlbum] 
  /// * [isOffline] 
  /// * [isReadOnly] 
  /// * [isVisible] 
  /// * [lensModel] 
  /// * [libraryId] 
  /// * [make] 
  /// * [model] 
  /// * [order] 
  /// * [originalFileName] 
  /// * [originalPath] 
  /// * [page] 
  /// * [personIds] 
  /// * [previewPath] 
  /// * [resizePath] 
  /// * [size] 
  /// * [state] 
  /// * [takenAfter] 
  /// * [takenBefore] 
  /// * [thumbnailPath] 
  /// * [trashedAfter] 
  /// * [trashedBefore] 
  /// * [type] 
  /// * [updatedAfter] 
  /// * [updatedBefore] 
  /// * [webpPath] 
  /// * [withArchived] 
  /// * [withDeleted] 
  /// * [withExif] 
  /// * [withPeople] 
  /// * [withStacked] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [BuiltList<AssetResponseDto>] as data
  /// Throws [DioException] if API call or serialization fails
  @Deprecated('This operation has been deprecated')
  Future<Response<BuiltList<AssetResponseDto>>> searchAssets({ 
    String? checksum,
    String? city,
    String? country,
    DateTime? createdAfter,
    DateTime? createdBefore,
    String? deviceAssetId,
    String? deviceId,
    String? encodedVideoPath,
    String? id,
    bool? isArchived,
    bool? isEncoded,
    bool? isExternal,
    bool? isFavorite,
    bool? isMotion,
    bool? isNotInAlbum,
    bool? isOffline,
    bool? isReadOnly,
    bool? isVisible,
    String? lensModel,
    String? libraryId,
    String? make,
    String? model,
    AssetOrder? order,
    String? originalFileName,
    String? originalPath,
    num? page,
    BuiltList<String>? personIds,
    String? previewPath,
    @Deprecated('resizePath is deprecated') String? resizePath,
    num? size,
    String? state,
    DateTime? takenAfter,
    DateTime? takenBefore,
    String? thumbnailPath,
    DateTime? trashedAfter,
    DateTime? trashedBefore,
    AssetTypeEnum? type,
    DateTime? updatedAfter,
    DateTime? updatedBefore,
    @Deprecated('webpPath is deprecated') String? webpPath,
    bool? withArchived = false,
    bool? withDeleted,
    bool? withExif,
    bool? withPeople,
    bool? withStacked,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/assets';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (checksum != null) r'checksum': encodeQueryParameter(_serializers, checksum, const FullType(String)),
      if (city != null) r'city': encodeQueryParameter(_serializers, city, const FullType(String)),
      if (country != null) r'country': encodeQueryParameter(_serializers, country, const FullType(String)),
      if (createdAfter != null) r'createdAfter': encodeQueryParameter(_serializers, createdAfter, const FullType(DateTime)),
      if (createdBefore != null) r'createdBefore': encodeQueryParameter(_serializers, createdBefore, const FullType(DateTime)),
      if (deviceAssetId != null) r'deviceAssetId': encodeQueryParameter(_serializers, deviceAssetId, const FullType(String)),
      if (deviceId != null) r'deviceId': encodeQueryParameter(_serializers, deviceId, const FullType(String)),
      if (encodedVideoPath != null) r'encodedVideoPath': encodeQueryParameter(_serializers, encodedVideoPath, const FullType(String)),
      if (id != null) r'id': encodeQueryParameter(_serializers, id, const FullType(String)),
      if (isArchived != null) r'isArchived': encodeQueryParameter(_serializers, isArchived, const FullType(bool)),
      if (isEncoded != null) r'isEncoded': encodeQueryParameter(_serializers, isEncoded, const FullType(bool)),
      if (isExternal != null) r'isExternal': encodeQueryParameter(_serializers, isExternal, const FullType(bool)),
      if (isFavorite != null) r'isFavorite': encodeQueryParameter(_serializers, isFavorite, const FullType(bool)),
      if (isMotion != null) r'isMotion': encodeQueryParameter(_serializers, isMotion, const FullType(bool)),
      if (isNotInAlbum != null) r'isNotInAlbum': encodeQueryParameter(_serializers, isNotInAlbum, const FullType(bool)),
      if (isOffline != null) r'isOffline': encodeQueryParameter(_serializers, isOffline, const FullType(bool)),
      if (isReadOnly != null) r'isReadOnly': encodeQueryParameter(_serializers, isReadOnly, const FullType(bool)),
      if (isVisible != null) r'isVisible': encodeQueryParameter(_serializers, isVisible, const FullType(bool)),
      if (lensModel != null) r'lensModel': encodeQueryParameter(_serializers, lensModel, const FullType(String)),
      if (libraryId != null) r'libraryId': encodeQueryParameter(_serializers, libraryId, const FullType(String)),
      if (make != null) r'make': encodeQueryParameter(_serializers, make, const FullType(String)),
      if (model != null) r'model': encodeQueryParameter(_serializers, model, const FullType(String)),
      if (order != null) r'order': encodeQueryParameter(_serializers, order, const FullType(AssetOrder)),
      if (originalFileName != null) r'originalFileName': encodeQueryParameter(_serializers, originalFileName, const FullType(String)),
      if (originalPath != null) r'originalPath': encodeQueryParameter(_serializers, originalPath, const FullType(String)),
      if (page != null) r'page': encodeQueryParameter(_serializers, page, const FullType(num)),
      if (personIds != null) r'personIds': encodeCollectionQueryParameter<String>(_serializers, personIds, const FullType(BuiltList, [FullType(String)]), format: ListFormat.multi,),
      if (previewPath != null) r'previewPath': encodeQueryParameter(_serializers, previewPath, const FullType(String)),
      if (resizePath != null) r'resizePath': encodeQueryParameter(_serializers, resizePath, const FullType(String)),
      if (size != null) r'size': encodeQueryParameter(_serializers, size, const FullType(num)),
      if (state != null) r'state': encodeQueryParameter(_serializers, state, const FullType(String)),
      if (takenAfter != null) r'takenAfter': encodeQueryParameter(_serializers, takenAfter, const FullType(DateTime)),
      if (takenBefore != null) r'takenBefore': encodeQueryParameter(_serializers, takenBefore, const FullType(DateTime)),
      if (thumbnailPath != null) r'thumbnailPath': encodeQueryParameter(_serializers, thumbnailPath, const FullType(String)),
      if (trashedAfter != null) r'trashedAfter': encodeQueryParameter(_serializers, trashedAfter, const FullType(DateTime)),
      if (trashedBefore != null) r'trashedBefore': encodeQueryParameter(_serializers, trashedBefore, const FullType(DateTime)),
      if (type != null) r'type': encodeQueryParameter(_serializers, type, const FullType(AssetTypeEnum)),
      if (updatedAfter != null) r'updatedAfter': encodeQueryParameter(_serializers, updatedAfter, const FullType(DateTime)),
      if (updatedBefore != null) r'updatedBefore': encodeQueryParameter(_serializers, updatedBefore, const FullType(DateTime)),
      if (webpPath != null) r'webpPath': encodeQueryParameter(_serializers, webpPath, const FullType(String)),
      if (withArchived != null) r'withArchived': encodeQueryParameter(_serializers, withArchived, const FullType(bool)),
      if (withDeleted != null) r'withDeleted': encodeQueryParameter(_serializers, withDeleted, const FullType(bool)),
      if (withExif != null) r'withExif': encodeQueryParameter(_serializers, withExif, const FullType(bool)),
      if (withPeople != null) r'withPeople': encodeQueryParameter(_serializers, withPeople, const FullType(bool)),
      if (withStacked != null) r'withStacked': encodeQueryParameter(_serializers, withStacked, const FullType(bool)),
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    BuiltList<AssetResponseDto>? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(BuiltList, [FullType(AssetResponseDto)]),
      ) as BuiltList<AssetResponseDto>;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<BuiltList<AssetResponseDto>>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// serveFile
  /// 
  ///
  /// Parameters:
  /// * [id] 
  /// * [isThumb] 
  /// * [isWeb] 
  /// * [key] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [Uint8List] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<Uint8List>> serveFile({ 
    required String id,
    bool? isThumb,
    bool? isWeb,
    String? key,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/file/{id}'.replaceAll('{' r'id' '}', encodeQueryParameter(_serializers, id, const FullType(String)).toString());
    final _options = Options(
      method: r'GET',
      responseType: ResponseType.bytes,
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (isThumb != null) r'isThumb': encodeQueryParameter(_serializers, isThumb, const FullType(bool)),
      if (isWeb != null) r'isWeb': encodeQueryParameter(_serializers, isWeb, const FullType(bool)),
      if (key != null) r'key': encodeQueryParameter(_serializers, key, const FullType(String)),
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    Uint8List? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : rawResponse as Uint8List;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<Uint8List>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// updateAsset
  /// 
  ///
  /// Parameters:
  /// * [id] 
  /// * [updateAssetDto] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [AssetResponseDto] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<AssetResponseDto>> updateAsset({ 
    required String id,
    required UpdateAssetDto updateAssetDto,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/{id}'.replaceAll('{' r'id' '}', encodeQueryParameter(_serializers, id, const FullType(String)).toString());
    final _options = Options(
      method: r'PUT',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      contentType: 'application/json',
      validateStatus: validateStatus,
    );

    dynamic _bodyData;

    try {
      const _type = FullType(UpdateAssetDto);
      _bodyData = _serializers.serialize(updateAssetDto, specifiedType: _type);

    } catch(error, stackTrace) {
      throw DioException(
         requestOptions: _options.compose(
          _dio.options,
          _path,
        ),
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    final _response = await _dio.request<Object>(
      _path,
      data: _bodyData,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    AssetResponseDto? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(AssetResponseDto),
      ) as AssetResponseDto;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<AssetResponseDto>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// updateAssets
  /// 
  ///
  /// Parameters:
  /// * [assetBulkUpdateDto] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> updateAssets({ 
    required AssetBulkUpdateDto assetBulkUpdateDto,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset';
    final _options = Options(
      method: r'PUT',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      contentType: 'application/json',
      validateStatus: validateStatus,
    );

    dynamic _bodyData;

    try {
      const _type = FullType(AssetBulkUpdateDto);
      _bodyData = _serializers.serialize(assetBulkUpdateDto, specifiedType: _type);

    } catch(error, stackTrace) {
      throw DioException(
         requestOptions: _options.compose(
          _dio.options,
          _path,
        ),
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    final _response = await _dio.request<Object>(
      _path,
      data: _bodyData,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    return _response;
  }

  /// updateStackParent
  /// 
  ///
  /// Parameters:
  /// * [updateStackParentDto] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> updateStackParent({ 
    required UpdateStackParentDto updateStackParentDto,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/stack/parent';
    final _options = Options(
      method: r'PUT',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      contentType: 'application/json',
      validateStatus: validateStatus,
    );

    dynamic _bodyData;

    try {
      const _type = FullType(UpdateStackParentDto);
      _bodyData = _serializers.serialize(updateStackParentDto, specifiedType: _type);

    } catch(error, stackTrace) {
      throw DioException(
         requestOptions: _options.compose(
          _dio.options,
          _path,
        ),
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    final _response = await _dio.request<Object>(
      _path,
      data: _bodyData,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    return _response;
  }

  /// uploadFile
  /// 
  ///
  /// Parameters:
  /// * [assetData] 
  /// * [deviceAssetId] 
  /// * [deviceId] 
  /// * [fileCreatedAt] 
  /// * [fileModifiedAt] 
  /// * [key] 
  /// * [duration] 
  /// * [isArchived] 
  /// * [isFavorite] 
  /// * [isOffline] 
  /// * [isReadOnly] 
  /// * [isVisible] 
  /// * [libraryId] 
  /// * [livePhotoData] 
  /// * [sidecarData] 
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [AssetFileUploadResponseDto] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<AssetFileUploadResponseDto>> uploadFile({ 
    required MultipartFile assetData,
    required String deviceAssetId,
    required String deviceId,
    required DateTime fileCreatedAt,
    required DateTime fileModifiedAt,
    String? key,
    String? duration,
    bool? isArchived,
    bool? isFavorite,
    bool? isOffline,
    bool? isReadOnly,
    bool? isVisible,
    String? libraryId,
    MultipartFile? livePhotoData,
    MultipartFile? sidecarData,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/asset/upload';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'apiKey',
            'name': 'cookie',
            'keyName': 'immich_access_token',
            'where': '',
          },{
            'type': 'apiKey',
            'name': 'api_key',
            'keyName': 'x-api-key',
            'where': 'header',
          },{
            'type': 'http',
            'scheme': 'Bearer',
            'name': 'bearer',
          },
        ],
        ...?extra,
      },
      contentType: 'multipart/form-data',
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (key != null) r'key': encodeQueryParameter(_serializers, key, const FullType(String)),
    };

    dynamic _bodyData;

    try {
      _bodyData = FormData.fromMap(<String, dynamic>{
        r'assetData': assetData,
        r'deviceAssetId': encodeFormParameter(_serializers, deviceAssetId, const FullType(String)),
        r'deviceId': encodeFormParameter(_serializers, deviceId, const FullType(String)),
        if (duration != null) r'duration': encodeFormParameter(_serializers, duration, const FullType(String)),
        r'fileCreatedAt': encodeFormParameter(_serializers, fileCreatedAt, const FullType(DateTime)),
        r'fileModifiedAt': encodeFormParameter(_serializers, fileModifiedAt, const FullType(DateTime)),
        if (isArchived != null) r'isArchived': encodeFormParameter(_serializers, isArchived, const FullType(bool)),
        if (isFavorite != null) r'isFavorite': encodeFormParameter(_serializers, isFavorite, const FullType(bool)),
        if (isOffline != null) r'isOffline': encodeFormParameter(_serializers, isOffline, const FullType(bool)),
        if (isReadOnly != null) r'isReadOnly': encodeFormParameter(_serializers, isReadOnly, const FullType(bool)),
        if (isVisible != null) r'isVisible': encodeFormParameter(_serializers, isVisible, const FullType(bool)),
        if (libraryId != null) r'libraryId': encodeFormParameter(_serializers, libraryId, const FullType(String)),
        if (livePhotoData != null) r'livePhotoData': livePhotoData,
        if (sidecarData != null) r'sidecarData': sidecarData,
      });

    } catch(error, stackTrace) {
      throw DioException(
         requestOptions: _options.compose(
          _dio.options,
          _path,
          queryParameters: _queryParameters,
        ),
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    final _response = await _dio.request<Object>(
      _path,
      data: _bodyData,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    AssetFileUploadResponseDto? _responseData;

    try {
      final rawResponse = _response.data;
      _responseData = rawResponse == null ? null : _serializers.deserialize(
        rawResponse,
        specifiedType: const FullType(AssetFileUploadResponseDto),
      ) as AssetFileUploadResponseDto;

    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<AssetFileUploadResponseDto>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

}
